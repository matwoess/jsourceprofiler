{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>jsourceprofiler is a command-line Java profiler that measures the frequency of method invocations  and code block executions in Java programs. It can be used to quickly identify hotspots in a Java program  and to determine code coverage. The tool will parse and instrument source files automatically, compile them, run the program (with arguments), and generate an HTML report.</p> <p>It was designed to be a command line tool that can easily be used in scripts, CI/CD pipelines, and automation. For Java/programming beginners, or users who are less familiar with the command line, a JavaFX tool-runner GUI was created (see JavaFx UI section).</p> <p>The five main stages of the profiler are:</p> <p></p> <p>This profiler instruments source code directly (as opposed to commonly used bytecode instrumentation) by inserting counter-statements at the beginning of every executable code block. Libraries or frameworks are not instrumented, only the user's code is.</p> <p>Blocks are found by parsing Java files with a recursive descent Scanner and Parser generated by the Coco/R tool using an attributed grammar (ATG). The ATG is tailored to the use-case of finding code blocks in a \"fuzzy\" way. (For details see Implementation Details section). This allows the grammar to be of minimal size and complexity and improves maintainability against the constantly updating and growing Java Language Specification.</p> <p>Compilation and execution are done using the Java Development Kit (JDK) tools <code>javac</code> and <code>java</code>. Build tools like Maven, Gradle, or Ant are currently not supported and may require manual intervention.</p> <p>The report provides a structured and sorted overview over the most frequently invoked methods and other useful metrics for each class and its methods. It further allows detailed exploration of source files and shows coverage (with counts) of grouped statements regions.</p>"},{"location":"dependencies/","title":"Dependencies","text":""},{"location":"dependencies/#runtime","title":"Runtime","text":"<ul> <li>OpenJDK 21</li> </ul>"},{"location":"dependencies/#report","title":"Report","text":"<ul> <li>jQuery</li> <li>Highlight.js</li> </ul>"},{"location":"dependencies/#build","title":"Build","text":"<ul> <li>Coco/R</li> <li>Gradle</li> <li>JavaFX</li> <li>AtlantaFX (Theme)</li> <li>gradle-download-task (to download Coco/R automatically)</li> </ul>"},{"location":"dependencies/#testing","title":"Testing","text":"<ul> <li>JUnit 5</li> <li>System Lambda</li> </ul>"},{"location":"dependencies/#publishing","title":"Publishing","text":"<ul> <li>Gradle Maven Publish Plugin</li> <li>MkDocs</li> <li>Material for MkDocs</li> <li>PyMdown Extensions</li> </ul>"},{"location":"fxui/","title":"JavaFX UI","text":"<p>An easy-to-use graphical application was created (using the JavaFX toolkit), to configure parameters and arguments for the command-line tool. It automatically calls the profiler in a new terminal window with the specified options.</p> <p>Golden (?) labels can be hovered over for more information about each field.</p>"},{"location":"fxui/#open-project-dialog","title":"Open project dialog","text":"<p>Before displaying the main application view, a project directory must be chosen, using the initial selection dialog.</p> <p></p> <p>Clicking Select will open the system's native file-picker dialog to choose a folder. Alternatively, the path can be entered directly into the text field.</p> <p>As soon as a valid folder path is entered, the main application window can be invoked with the Open button.</p> <p>The entered path will be stored in a local file and pre-filled on the next program execution.</p>"},{"location":"fxui/#main-application-window","title":"Main application window","text":"<p>Using the file tree on the left, the sources directory and main file can be selected. Depending on the run mode this may be required.</p> <p>Assigning a file or directory to a parameter field can be done by the Return key, or using the context menu on a any item in the tree.</p> <p>The tree view highlights important items in color:</p> <ul> <li>blue for the selected sources directory</li> <li>green for the selected main file</li> <li>brown for the (hidden) output directory <code>.profiler</code></li> </ul> <p>The top menu bar allows rebuilding the file tree and saving or restoring currently set parameters (will be saved in the output directory as <code>parameters.dat</code>).</p> <p>When clicking Run tool, a system-native terminal will be launched, showing the program output and allowing user input (useful for interactive programs). The terminal application to use can be selected in the user interface.</p> <p>The effectively executed terminal command can be previewed with the Preview command button.</p> <p>Open report will only show up once the <code>.profiler/report/index.html</code> file exists. Clicking it opens the report in the system's default application for HTML files (usually a browser).</p>"},{"location":"fxui/#javafx-theme","title":"JavaFX Theme","text":"<p>The UI currently uses the <code>PrimerDark</code> theme from AtlantaFX as a <code>userAgentStylesheet</code>.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#download-and-use","title":"Download and use","text":"<p>The Releases section contains downloadable <code>.jar</code>-archives for the tool and portable zip files containing the  JavaFX tool-runner application. The command-line tool is platform-independent and can be run on any system with a  Java Development Kit (JDK) installed. The \"fxui\" has separate releases for Windows, Linux and macOS. The archives provide executable scripts to directly start the GUI without using the command line  (located in the <code>bin/</code> subfolder).</p> <p>For detailed instructions on how to use the command-line tool, see the Usage section. For an introduction to the JavaFX tool-runner GUI, see the JavaFX UI section.</p>"},{"location":"getting-started/#building-from-source","title":"Building from source","text":"<p>To build the project from source, Gradle and a Java JDK of version 21 or newer are required.</p> <p>After that it's as simple as: <pre><code>./gradlew build\n</code></pre></p>"},{"location":"getting-started/#generating-the-parser-automatic-task","title":"Generating the parser (automatic task)","text":"<p>After cloning or downloading the source code, the <code>Scanner.java</code> and <code>Parser.java</code> files must first be generated using the Coco/R library. This should be done automatically by our custom <code>generateParser</code> Gradle build step. It will download Coco/R to the <code>lib/</code> folder and use it to create the needed files using the project's ATG file  (together with the <code>Scanner.frame</code> and <code>Parser.frame</code> files). The task is added as a dependency to the <code>compileJava</code>  and <code>sourcesJar</code> tasks and will be called by Gradle when building the project.</p> <p>This step could also be done manually by downloading Coco/R and executing the following command in the project's root directory, to (re-)generate the parser files at any time:</p> <pre><code>java -jar jsourceprofiler-tool/lib/Coco.jar \\\n  -o jsourceprofiler-tool/src/main/java/org/matwoess/jsourceprofiler/tool/instrument \\\n  -package org.matwoess.jsourceprofiler.tool.instrument \\\n  jsourceprofiler-tool/src/main/parsergen/JavaFile.atg \n</code></pre>"},{"location":"getting-started/#additional-build-targets","title":"Additional build targets","text":"<p>To create a single \"fat\" JAR that contains both <code>jsourceprofiler-tool</code> and <code>jsourceprofiler-common</code> in one archive (for easier use with the command-line) a <code>fatJar</code> build target is provided. This task is currently used to make the <code>profiler-x.y.z.jar</code> artifacts for the Releases section.</p>"},{"location":"getting-started/#include-as-a-dependency","title":"Include as a dependency","text":"<p>Additionally to the ready-to-use releases, the tool can be included in other projects as a Maven dependency. It is available on the GitHub Package Registry  and on Maven Central.</p> <p>The command-line tool can be included in a Maven project by adding the following dependency to the <code>pom.xml</code> file:</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.matwoess&lt;/groupId&gt;\n  &lt;artifactId&gt;jsourceprofiler-tool&lt;/artifactId&gt;\n  &lt;version&gt;0.12.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.matwoess&lt;/groupId&gt;\n  &lt;artifactId&gt;jsourceprofiler-common&lt;/artifactId&gt;\n  &lt;version&gt;0.12.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>When using Gradle, the following lines can be added to the <code>build.gradle</code> file:</p> <pre><code>dependencies {\n    implementation(\"org.matwoess:jsourceprofiler-tool:0.12.0\")\n    implementation(\"org.matwoess:jsourceprofiler-common:0.12.0\")\n}\n</code></pre>"},{"location":"implementation-details/","title":"Implementation details","text":"<p>This section gives some more information on how the profiler works in detail.</p>"},{"location":"implementation-details/#grammarparser","title":"Grammar/Parser","text":"<p>The Grammar consists of a reduced set of non-terminal symbols (NTS) that covers the most important aspects of the Java 21 syntax, tailored for the profiler's use-case: finding the start and end position of blocks.</p> <p>Using Coco's <code>ANY</code> keyword, we over-read non-relevant tokens like:</p> <ul> <li>access modifiers (<code>public</code>, <code>private</code>, ... )</li> <li>interfaces that a class <code>implements</code> (or superclasses)</li> <li>class level constants and member variables</li> <li>generic type definitions with angle brackets <code>&lt;Type1&lt;Type2,...&gt;, ...&gt;</code></li> <li>array initializer blocks (starting with <code>{</code>), but we do not insert counters here</li> <li>a method\u2019s argument list (within the parentheses)</li> <li>remaining tokens in a <code>GenericStatement</code> up to the semicolon</li> <li>a switch's case label(s), constant(s) and guard clause(s) before the colon or arrow</li> </ul> <p>To build an index of classes and their methods, we have to keep track of class and method names  in each file and assign them to the block objects in the model. Package declarations at the beginning of a file have to be propagated to each class to determine fully qualified names.</p> <p>Therefore, we used the semantic action syntax of Coco/R to insert our custom statements into the final generated parser file. Arbitrary Java statements can be included in the ATG in the form of <code>(. STATEMENT; .)</code> blocks. We use this to add hooks for our <code>ParserState</code> helper class.</p> <p>E.g. to parse the full package name an NTS like this could be defined:</p> JavaFile.atg<pre><code>PackageDecl = \"package\"     (. ArrayList&lt;String&gt; packageName = new ArrayList&lt;&gt;(); .)\n    ident                   (. packageName.add(t.val); .)\n    {'.' ident              (. packageName.add(t.val); .)\n    }\n    \";\"                     (. state.setPackageName(packageName); .)\n.\n</code></pre> <p>Which would result in the following generated parser (pseudo-code) method: </p> Parser.java<pre><code>void PackageDecl() {\n    Expect(\"package\");\n    ArrayList&lt;String&gt; packageName = new ArrayList&lt;&gt;(); \n    Expect(IDENT);\n    packageName.add(t.val); \n    while (la.kind == DOT) {\n        Get();\n        Expect(IDENT);\n        packageName.add(t.val); \n    }\n    Expect(\";\");\n    state.setPackageName(packageName); \n}\n</code></pre> <p>(where <code>t</code> is the current token, <code>la</code> the look-ahead token and <code>state</code> the <code>ParserState</code> instance)</p> <p>In this way our state class is automatically updated during the recursive-descent parsing of Java source files, and we can build our metadata whenever we encounter a new relevant token.</p>"},{"location":"implementation-details/#instrumentation","title":"Instrumentation","text":"<p>The tool parses source code files and stores an instrumented copy in the output directory. At the beginning of executable code blocks (usually after an opening brace <code>{</code>). a <code>__Counter.inc(X);</code> statement is inserted.</p> <p>A program like: <pre><code>class Fibonacci {\n  static int fib(int n) {\n    if (n &lt;= 1) {\n      return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n  }\n  public static void main(String[]args) {\n    int N = Integer.parseInt(args[0]);\n    for (int i = 1; i &lt; N; i++) {\n      System.out.print(fib(i) + \" \");\n    }\n  }\n}\n</code></pre></p> <p>Would look in its instrumented version something like this: <pre><code>\"import auxiliary.__Counter;\"\nclass Fibonacci {\n  static int fib(int n) {\"__Counter.inc(0);\"\n    if (n &lt;= 1) {\"__Counter.inc(1);\"\n      return n;\n    }\n    return fib(n - 1) + fib(n - 2);\n  }\n  public static void main(String[] args) {\"__Counter.inc(2);\"\n    int N = Integer.parseInt(args[0]);\n    for (int i = 1; i &lt; N; i++) {\"__Counter.inc(3);\"\n      System.out.print(fib(i) + \" \");\n    }\n  }\n}\n</code></pre></p> <p>Counter statements are always appended to the end of a line, to preserve the original line numbers. This is especially important for getting correct lines numbers when an exception is thrown during execution  of the instrumented program.</p>"},{"location":"implementation-details/#the-__counter-class","title":"The <code>__Counter</code> class","text":"<p>To successfully compile a copy of the program with additional <code>__Counter.inc(x)</code> statements, we need to import the <code>__Counter</code> class inside each instrumented file. The class is contained in a root-level <code>auxiliary</code> package so that can be imported at any level in the hierarchy.</p> <p>A compiled <code>.class</code> version of <code>__Counter</code> is extracted from the tool's JAR and copied to the <code>instrumented/</code> and <code>classes/</code> output directories.</p> <p>The counter class stores an array the size of all (number of) all found blocks in the entire project. Every <code>__Counter.inc(idx)</code> statement includes the block index <code>idx</code> to increment.</p> <p>By default, calls to <code>inc</code> are not synchronized to speed up runtime performance. Using the <code>-s</code> / <code>--synchronized</code> option we insert <code>incSync</code> statements instead. The counters are then kept in an <code>AtomicLongArray</code> to ensure exact results for multi-threaded programs.</p>"},{"location":"implementation-details/#special-handling-of-language-features","title":"Special handling of language features","text":"<p>Some language syntax constructs required special non-trivial handling during instrumentation.</p>"},{"location":"implementation-details/#single-statements","title":"Single-statements","text":"<p>We cannot just add a counter-statement to brace-less single-statement blocks.  They have to be wrapped in braces for it to compile successfully.</p> <p>The following example:</p> <pre><code>boolean containsZero(int[][] array) {\n  if (array == null) return false;\n  for (int i = 0; i &lt; array.length; i++)\n    for (int j = 0; j &lt; array[i].length; j++)\n      if (array[i][j] == 0) return true;\n  return false;\n}\n</code></pre> <p>would require insertions of:</p> <pre><code>boolean containsZero(int[][] array) {\"__Counter.inc(261);\"\n  if (array == null)\"{__Counter.inc(262);\" return false;\"}\"\n  for (int i = 0; i &lt; array.length; i++)\"{__Counter.inc(263);\"\n    for (int j = 0; j &lt; array[i].length; j++)\"{__Counter.inc(264);\"\n      if (array[i][j] == 0)\"{__Counter.inc(265);\" return true;\"}}}\"\n  return false;\n}\n</code></pre>"},{"location":"implementation-details/#overloaded-constructors","title":"Overloaded constructors","text":"<p>Java supports multiple \u201coverloaded\u201d constructors in the same class. If we use <code>super()</code> or <code>this()</code> invocations, the language (currently) enforces that it must be the first statement in the method body. This makes it impossible to insert a <code>__Counter.inc(X);</code> statement right after the method's opening brace.</p> <p>To handle this special case, we need to keep track of the end position of possible first <code>this/super</code> calls in constructors. The counter-statement is added only after this call.</p> <pre><code>class SmallDog extends Dog {\n  public SmallDog(String name, int age) {\n    super(name, age);\"__Counter.inc(3);\"\n    size = Size.SMALL;\n    super.speak();\n  }\n  public SmallDog(String name, int age, Size s) {\n    this(n, age);\"__Counter.inc(4);\"\n    this.size = s;\n  }\n  ...\n}\n</code></pre>"},{"location":"implementation-details/#anonymous-and-local-classes","title":"Anonymous and local classes","text":"<p>As these full-fledged classes can appear anywhere inside a code block, we need need to restore the previous state after entering, parsing, and exiting these inner classes. For this, the <code>ParserState</code> class contains a Stack for methods, onto which we push the current one when encountering class declarations inside methods. As soon as we exit the class, we pop the method from the stack and continue parsing the outer method.</p>"},{"location":"implementation-details/#brace-less-lambdas","title":"Brace-less Lambdas","text":"<p>Lambda statements are often used without a method body, especially for stream processing.</p> <p>Given the example:</p> <pre><code>integers.stream()\n        .peek(x -&gt; System.out.println(x))\n        .filter(x -&gt; x % 2 == 0)\n        .sum();\n</code></pre> <p>We need a clever way to observe how often each lambda statement was executed.</p> <p>The <code>__Counter</code> class contains a special <code>incLambda</code> method that wraps these lambdas as an argument into either a generic anonymous <code>Runnable</code> or <code>Supplier&lt;T&gt;</code>.</p> <p>The instrumented version would look like this:</p> <pre><code>integers.stream()\n        .peek(x -&gt;\"__Counter.incLambda(61, () -&gt;\" System.out.println(x)\")\")\n        .filter(x -&gt;\"__Counter.incLambda(62, () -&gt;\"  x % 2 == 0\")\")\n        .sum();\n</code></pre> <p>The compiler will automatically choose the fitting <code>incLambda</code> variant to call, depending on the return type.</p>"},{"location":"implementation-details/#switch-statements-and-switch-expressions","title":"Switch statements and switch expressions","text":"<p>Switch statements need a lot of special handling due to their abnormal syntax.  The switch block itself is not executable, <code>case</code> blocks are not enclosed in braces.  Switch expression (introduced in Java 14) have the <code>yield</code> statement to return a value.  We also can use arrow-cases (same <code>-&gt;</code> operator as for lambdas) to omit the <code>break</code>, in which case there's either a curly-brace block or a single statement.</p> <p>For the case of single-statement arrow-case expressions we need to wrap the block in braces and add a <code>yield</code> keyword after the counter statement.  In case a branch throws an exception, <code>yield</code> must not be added.</p> <p>The following example:</p> <pre><code>StatusCode statusCode = ...;\nint sc = switch (statusCode) {\n  case OK -&gt; 200;\n  case UNAUTHORIZED -&gt; 401;\n  case FORBIDDEN -&gt; 403;\n  case NOTFOUND -&gt; { yield 404; }\n  default -&gt; throw new RuntimeException(\"invalid code\");\n};\n</code></pre> <p>is instrumented as following:</p> <pre><code>StatusCode statusCode = ...;\nint sc = switch (statusCode) {\n  case OK -&gt;\"{__Counter.inc(5); yield\" 200;\"}\"\n  case UNAUTHORIZED -&gt;\"{__Counter.inc(6); yield\" 401;\"}\"\n  case FORBIDDEN -&gt;\"{__Counter.inc(7); yield\" 403;\"}\"\n  case NOTFOUND -&gt; {\"__Counter.inc(8);\" yield 404; }\n  default -&gt; \"{__Counter.inc(9);\" throw new RuntimeException(\"invalid code\");\"}\"\n};\n</code></pre>"},{"location":"implementation-details/#control-flow-breaks","title":"Control flow breaks","text":"<p>The keywords <code>break</code>, <code>continue</code>, <code>return</code>, <code>yield</code> and <code>throw</code> are used to exit a block early. As our counters are inserted only at the beginning of blocks, we would need another counter after every block (containing a control flow break statement) to correctly show line-hit coverage.</p> <p>We took a different approach by introducing \"code regions\" to group together statements with the same hit count. A code block is split into two regions when encountering an inner block. If the inner block contains a control flow break, we subtract the hit count of the inner blocks from the previous region's hit-count to calculate how frequently the following region was executed.</p> <pre><code>275     | static int fib(int n) {\n275     |   if (n &lt;= 1)\n275 142 |     return n;\n275     |   return fib(n - 1) + fib(n - 2); // 275-142 = 133\n        | }\n</code></pre>"},{"location":"limitations/","title":"Limitations","text":""},{"location":"limitations/#general","title":"General","text":"<ul> <li>Only the project itself is instrumented (libraries without source code cannot be included)</li> <li>Run-time exceptions (and skipped statements) inside and outside of <code>try</code> blocks cannot be considered for the   resulting coverage data.</li> </ul>"},{"location":"limitations/#temporary","title":"Temporary","text":"<ul> <li>Custom build tools (like Ant, Maven and Gradle) are not supported yet.</li> <li>Imperfect grammar:<ul> <li>The ATG is kept simple, minimal and generic. While we can successfully parse and instrument large projects,   we do not claim to find every possible code block. The fuzzy approach leads to some special structures   being currently ignored.</li> </ul> </li> <li>The hit count alone does not tell us how long it took to execute a code block </li> </ul>"},{"location":"report/","title":"Report","text":"<p>The profiler generates an HTML report inside the <code>.profiler/report/</code> output directory.  The <code>index.html</code> file can be opened in a browser to view it.</p> <p>Additionally, a symbolic link or Windows shortcut will be created in the current working directory linking to the index file.</p>"},{"location":"report/#classes-overview-indexhtml","title":"Classes overview (index.html)","text":"<p>The main index file lists all classes found during parsing.</p> <p></p> <p>By default, the list is sorted by the aggregated invocation count of all methods in each listed class. This enables us to quickly identify hotspots in the program for its last run. At the bottom of the list we find rarely or never used classes.</p> <p>Two additional metrics are available:</p> <ul> <li>the method coverage in percent</li> <li>the hit-count of the \"hottest\" block inside the entire class</li> </ul> <p>The columns are clickable and allow re-sorting of the rows by an alternative metric.  Clicking on the class name will open the \"Methods\" index for this class.  By clicking on the source file link, we can jump directly to this file's detail view.</p>"},{"location":"report/#methods-overview-index_classnamehtml","title":"Methods overview (index_ClassName.html)","text":"<p>A separate method index is created for each top-level class.  It lists all (non-abstract) methods, sorted by invocation count.</p> <p></p> <p>The heading displays the fully-qualified name of the class (including package prefix).</p> <p>Methods of inner classes are shown with the Java class file syntax: <code>Outer$Inner::Method</code>. Anonymous and local classes get a numbered name <code>Outer$3::Method</code>, just like the compiled Java class files.</p> <p>Clicking on a method name will jump into the source code view, directly to the line number of the method's declaration.</p> <p>Browser-back or the button on top of the file can be used to return to the class overview page.</p>"},{"location":"report/#source-file-detail-view-javafilenamehtml","title":"Source file detail view (JavaFileName.html)","text":"<p>For each Java file, an annotated source code file is generated inside <code>.profiler/report/source/</code>. It can be used to explore the methods and statements of each class in detail and get coverage information.</p> <p>A small jQuery script file initializes colors for relevant sections and dynamically updates them on mouse hover. Syntax highlighting is provided by highlight.js.  The line numbers are added by pure CSS and the hit-counter column is created dynamically on page-load.</p> <p></p> <p>Code blocks that have been entered at least once during program execution are highlighted in green. Never-covered blocks are displayed with a red background color.</p> <p>Statements with the same hit count are grouped into \"code regions\". These regions are shown in a darker, more opaque green and red (depending on their coverage status).</p> <p>The column, to the right of the line numbers, contains the region's hit counts for each line.  If multiple code regions start in the same line, the hits are shown stacked next to each other.</p> <p>Hovering over a block or region will highlight the entire block in yellow and statements of the current region in orange. The current region's code will also become bold until moving the mouse away from it. Additionally, a popup will show the number of hits from the current block or region.</p>"},{"location":"runtime-impact/","title":"Runtime impact","text":"<p>To evaluate how much the inserted counter statements impact the run-time performance of a program, we ran a few benchmarks from the DaCapo Benchmark Suite in three different configurations:</p> <ul> <li>\"orig\" \u2014 The original, unmodified benchmark program without instrumentation</li> <li>\"instr\" \u2014 A version with counter-increment statements added to every code block</li> <li>\"sync\" \u2014 The benchmark with synchronized counters (using the <code>AtomicLongArray</code>)</li> </ul> <p>The following figure shows the average relative run-time overhead of seven benchmarks programs compared to their un-instrumented version:</p> <p></p> <p>Most benchmarks show only a relatively small slowdown to less than 200% run time. The \"h2\" program does not show any significant impact as most of its work in performed in its derby database library, which is not instrumented. The sunflow benchmark (multi-threaded CPU ray-tracing) is the opposite extreme, showing a significant 10-fold run time impact when using synchronized counters.</p> <p>For further analysis and details, see the thesis paper.</p>"},{"location":"usage/","title":"Usage","text":"<p>The tool defines the following command line interface:</p> <p><pre><code>Usage: profiler [options] &lt;main file&gt; [program args]  \nOr   : profiler [options] &lt;run mode&gt;\n</code></pre> The <code>java</code> and <code>javac</code> JDK binaries have to be included in the system environment path for the tool to function correctly. The absolute file system location of the executables is not determined automatically.  They are invoked with their respective names in a sub-process.</p> <p>All tool output is stored inside the hidden <code>.profiler</code> subdirectory of the current working directory.  It is created automatically if it does not exist.</p> <p>For being able to use local project resources and relative paths (as arguments or inside the program itself) the tool never changes its working directory during execution. Instead, the classpath is set to the instrumented copies inside the <code>.profiler</code> directory. It is therefore recommended to run the command line tool in the project's root directory (just like you would for using <code>java</code> and <code>javac</code>).</p> <p>In the simplest case the tool can be invoked with a single Main file as its target. If the program-to-profile consists of multiple class source files the <code>--sources-directory</code> (<code>-d</code>) parameter is required! Setting this parameter instructs the tool to parse all Java files in the given directory and its subdirectories.</p>"},{"location":"usage/#shell-script","title":"Shell script","text":"<p>For frequent use, it is recommended to create a shell script or batch file that contains the necessary commands. ~/bin/profile<pre><code>#!/usr/bin/env bash\njava -jar ~/.local/lib/profiler-0.12.0.jar $@\n# java -&gt; /usr/lib/jvm/java-21-openjdk/bin/java\n</code></pre></p> <p>This script can then be placed in a directory that is included in the system's PATH variable. It allows the tool to be called from any location in the terminal by its file name (e.g. <code>profile</code>).</p> <p>(In the rest of this file the <code>java -jar profiler.jar</code> command is substituted by <code>profile</code>)</p>"},{"location":"usage/#command-line-options","title":"Command line options","text":"<p>There are a few optional arguments available. For a full list, see the <code>-h</code> or <code>--help</code> arguments.</p>"},{"location":"usage/#-sources-directory","title":"<code>--sources-directory</code>","text":"<p>If the project-to-profile consists of two or more (linked) Java files, the sources directory has to be specified. This is done with the <code>-d</code> or <code>--sources-directory</code> option:</p> <pre><code>profile -d src/main/java/ src/main/java/subfolder/Main.java\n</code></pre> <p>This is necessary, because we cannot know all dependent and referenced source files at the source code instrumentation  stage without help from the Java compiler. Using this option, all <code>.java</code> files inside <code>src/main/java/</code> will be parsed, instrumented and copied to the <code>.profiler/instrumented</code> directory. The relative folder-structure is replicated to ensure successful compilation  (<code>javac</code> will throw an error if the package name and file paths mismatch).</p>"},{"location":"usage/#-synchronized","title":"<code>--synchronized</code>","text":"<p>When adding <code>-s</code> or <code>--synchronized</code> as a option, all inserted counters will be incremented atomically. This might be useful for multi-threaded programs, where a few methods or blocks are constantly executed in parallel. It will ensure that hit counts are correct, but runtime performance will be impacted.</p>"},{"location":"usage/#-verbose","title":"<code>--verbose</code>","text":"<p>This option is mainly for debugging purposes. It can be activated with <code>-v</code> or <code>--verbose</code> and will output detailed information about the parsing process for each file.</p>"},{"location":"usage/#run-modes","title":"Run modes","text":"<p>The tool is primarily designed for easy usage with small projects that have a Main file. In case the project cannot be compiled with <code>javac Main.java</code>, or uses build tools (like Maven, Gradle, or Ant), we cannot use the default compilation logic.</p> <p>For this case, two additional run modes are available:</p>"},{"location":"usage/#-instrument-only","title":"<code>--instrument-only</code>","text":"<p>By specifying the <code>-i &lt;file|dir&gt;</code> or <code>--instrument-only &lt;file|dir&gt;</code> mode the target file (or directory with all its Java files) will be instrumented and written to the <code>.profiler/instrumented/</code> directory. The <code>metadata.dat</code> file will also be generated. The instrumented code can then be compiled by custom commands and run manually.</p>"},{"location":"usage/#-generate-report","title":"<code>--generate-report</code>","text":"<p>If a project was already instrumented and run, the HTML report can be quickly (re-)generated with the <code>-r</code> or <code>--generate-report</code> run mode. In this mode, no parsing or instrumentation will be done. For it to succeed both the <code>metadata.dat</code> and <code>counts.dat</code> files must already exist in the <code>.profiler</code> output directory. Otherwise, the tool will abort with an error message.</p>"},{"location":"usage/#sample-usage","title":"Sample usage","text":""},{"location":"usage/#single-file-projects","title":"Single file projects","text":"<p>If the entire program-to-profile is contained in a single Java source file <code>App.java</code>, the tool can be used as following: <pre><code>profile App.java arg1 arg2 ...\n</code></pre> This will parse, instrument and compile the given file, execute the program with the given arguments, and create a report.</p>"},{"location":"usage/#multi-file-projects","title":"Multi-file projects","text":"<p>If the program consists of multiple Java files, the sources directory has to be specified:</p> <pre><code>profile -d src/ src/App.java arg1 arg2 ...\n</code></pre> <p>This will parse all <code>*.java</code> files in the sources directory and create an instrumented copy. The first positional parameter to the tool specifies the class containing the main entry point.  Its instrumented copy will be used to run the program.</p>"},{"location":"usage/#run-modes-and-custom-compilation","title":"Run modes and custom compilation","text":"<p>In case the project cannot be compiled with <code>javac App.java</code>, the two additional run modes can be used:</p> <p><pre><code>profile --instrument-only src/\njavac -cp .profiler/instrumented -customArg .profiler/instrumented/App.java\njava -cp .profiler/instrumented App\nprofile --generate-report\n</code></pre> This way the <code>-customArg</code> can be passed to the <code>javac</code> command.  Instead of lines 2-3 any other custom command like <code>ant</code>/<code>gradlew</code>/.. can be substituted.</p>"},{"location":"workflow/","title":"Tool Workflow","text":"<p>This section further describes the inner workings of jsourceprofiler in more detail.</p> <p>The workflow of the profiler is divided into the five stages:</p> <p></p>"},{"location":"workflow/#analyze-and-instrument","title":"Analyze and Instrument","text":"<p>After parsing all Java sources, the <code>.profiler/metadata.dat</code> file will be created. It contains information about every found code block, used for instrumentation and creation of the report. </p> <p>Some example data are:</p> <ul> <li>the unique ID of a block (index in order of found)</li> <li>the start/end position and line number</li> <li>a pointer to the outer block (if any)</li> <li>the block's parent method/class/package</li> <li>its type (method, if, for, switch, ...)</li> </ul> <p>All instrumented source file copies are written to <code>.profiler/instrumented/</code>.</p>"},{"location":"workflow/#compile","title":"Compile","text":"<p>The tool will then automatically compile the instrumented version using the <code>javac</code> compiler. (the tool executes this command internally)<pre><code>javac -cp .profiler/instrumented -d .profiler/classes App.java\n</code></pre> (whereas <code>App.java</code> is the specified main file)</p> <p>The Java compiler finds referenced Java files (used in <code>App</code>) automatically and compiles them next into (instrumented) <code>.class</code> files. The compiled classes will be written to the <code>.profiler/classes/</code> directory.</p> <p>Inserted counters use the <code>auxiliary.__Counter</code> class to increment the hit-counters. For the instrumented code to compile, the pre-built <code>auxiliary</code> package is extracted and copied to <code>.profiler/instrumented/</code> by the profiler.</p> <p>Classes that are not used in the main file or its referenced classes will not be compiled.</p>"},{"location":"workflow/#execute","title":"Execute","text":"<p>Next, the <code>java</code> binary is used to execute the instrumented copy of the specified class by name (without the <code>.java</code> extension) and with the given arguments: (the tool executes this command internally)<pre><code>java -cp .profiler/classes App arg1 arg2 ...\n</code></pre></p> <p>Again, for this to work, the <code>auxiliary</code> package is copied to the <code>.profiler/classes/</code> directory.</p> <p>Executing the instrumented files, automatically stores the hit-counter values in <code>.profiler/counts.dat</code> as soon as the program execution is finished and the JVM shuts down. This is done by a shutdown hook in the <code>__Counter</code> class and a hard-coded path.</p> auxiliary.__Counter.java<pre><code>public class __Counter {\n  static {\n    init(\".profiler/metadata.dat\");\n    Runtime.getRuntime().addShutdownHook(\n        new Thread(() -&gt; save((\".profiler/counts.dat\"))));\n  }\n  ...\n}\n</code></pre>"},{"location":"workflow/#report","title":"Report","text":"<p>Finally, the metadata and counts will be used to generate the report inside <code>.profiler/report/</code>.</p> <p>Afterward, a <code>report.html</code> link to the report will be created in the current working directory, pointing to <code>.profiler/report/index.html</code>. On Linux or macOS it will be a symbolic link, on Windows a <code>report.lnk</code> shortcut file.</p> <p>The HTML report can then be used to find hotspots during the last execution (further described in the Report section).</p>"}]}